#Chapter 8  查找

	#查找表是由同一类型的数据元素（或记录）构成的集合
		关键字是数据元素中某个数据项的值
		若此关键字可以唯一地标识一个记录，则称此关键字为主关键字
		对于那些可以识别多个数据元素的关键字，称为次关键字


	查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素


	#查找表分类
		按照操作方式：静态查找表和动态查找表

			#静态查找表：只作查找操作的查找表
				查询某个特定的数据元素是否在查找表中
				检索某个特定的数据元素和各个属性

			#动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素
				查找时插入数据元素
				查找时删除数据元素

	#折半查找（二分查找）
		前提是线性表中记录关键码有序，线性表必须采用顺序存储
		基本思想：在有序表中，取中间记录作为比较对象，若给定值与中间记录关键字相同，则查找成功；若给定值小于中间记录的关键字
		，则在中间记录的左半区继续查找，大于则在右半区，不断重复上述过程，直到查找成功，或无记录。
		（ O(log n)）
		#对于静态查找表，一次排序后不再变化，这样算法比较好。但对于需要频繁执行插入或删除操作的数据集，排序工作量大，不建议使用

	#插值查找：
		折半查找中， mid = low + (high - low) / 2
		修改1/2     mid = low + (high - low) * (key - a[low]) / (a[high] - a[low])
		根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法。核心公式在于 (key - a[low]) / (a[high] - a[low])
		对于表长较大，关键字分布比较均匀的查找表来说，插值查找算法平均性能比折半查找好得多
		但对于分布极端不均匀的数据，插值查找未必合适

	#斐波那契查找：
		key = a[mid],查找成功
		key < a[mid]，新范围是第low个到第mid - 1个，此时范围个数为F[k - 1] - 1个
		key > a[mid]，新范围是m + 1个到底high个，此时范围个数为F[k - 2] - 1个

		若始终在左侧长半区查找，则算法效率可能低

	#索引
		索引就是把一个关键字与它对应的记录相关联的过程
		按照结构可分为线性索引、树形索引和多级索引

		所谓线性索引就是索引项集合组织为线性结构，也称索引表

			#稠密索引
				指在线性索引中，将数据集中的每个记录对应一个索引项
				对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列

				优点在于索引码有序，而当数据集很大时，索引表规模大。


			#分块索引（图书馆）
				减少索引项的个数，分块有序：
					块内无序，块间有序
						平均查找长度：设n个记录被分成m块，每块t条记录
						Lb为查找索引表的平均查找长度。 Lb = (m + 1) / 2
						Lw为块内平均查找长度. Lw = (t + 1) / 2
						平均长度 = Lb + Lw
						 = √n + 1

			#倒排索引
				次关键码
				记录号表

				记录号表存储具有相同次关键字的所有记录的记录号
				这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址，由于不是由记录来确定属性值，
				而是由属性值来确定记录的位置，因而称为倒排索引。

				优点在于查找记录非常快，而缺点是记录号不定长。索引表维护困难。

		#二叉排序树：
			或者是一棵空树，或者具有以下性质的二叉树：
				若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
				若它的右子树不空，则右子树上所有结点的值均大于大的根结点的值
				它的左右子树也分别为二叉排序树

			为了提高查找和插入删除关键字的速度。

			#删除结点：
				如下三种情况：叶子结点
							仅有左或右子树的结点
							左右子树都有的结点（找到需要删除的结点p的直接前驱s（或直接后继），s来替换p，再删除s）

		#平衡二叉树（AVL树）
			是一种二叉排序树，其中每一个结点的左子树和右子树高度差至多等于1
			或者是一棵空树，或者左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差绝对值不超过一。
			将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF。
			平衡二叉树上所有结点的平衡因子之可能是-1，0，1
			距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树


			#平衡二叉树实现原理
				在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不
				平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡树中各结点之间的链接关系，进行相应的旋转，使之
				成为新的平衡子树。


		#多路查找树：
			其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素

			#2-3树
				其中每一个结点都具有两个孩子（2结点）或三个孩子（3结点）

				一个2结点包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素。
				这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。
				
				一个3结点包含一小一大两个元素和三个孩子（或没有孩子），左子树包含小于较小元素的元素，右子树包含大于较大元素的
				元素，中间子树包含介于两个元素之间的元素。要么没有孩子，要么具有3个孩子。

				2-3树中所有的叶子都在同一层次上。


				#2-3树插入
					插入：三种情况
							1.空树，直接插入2结点
							2.插入结点到一个2结点的叶子上，只需将其升级为3结点
							3.往3结点中插入新元素。需要拆分，且将树中两元素或插入元素中选择其一向上移动一层。

						如果2-3树插入的传播效应导致了根结点的拆分，则树的高度会增加。

			#2-3-4树
				2-3树的扩展，包括了4结点的使用


		B-tree:
			是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例
			结点最大的孩子数目成为B树的阶

			一个m阶B树具有如下属性：
				1.如果根结点不是叶结点，则其至少有两棵子树
				2.每一个非跟的分支结点都有k - 1个元素和k个孩子，其中[m/2] <= k <= m。每一个叶子结点n都有k - 1个元素，其中[m/2] <= k <= m
				3.所有的叶子结点都位于同一个层次。
				4.所有分支结点包含下列信息数据(n,A0,K1,K2,A2,...,Kn,An)，其中Ki为关键字，且Ki < Ki+1，Ai为指向子树根结点的指针，且Ai-1所指子树所有结点关键字均小于Ki，An所指子树中所有结点的关键字均大于Kn，n（[m/2] - 1 <= n <= m - 1）为关键字个数（或n+1为子树个数）

				含有n个关键字的B树上查找，从根结点到关键字的路径上涉及的结点树不超过log[m/2]((n + 1))/2 + 1

		B+树
			根结点中的关键字在叶子结点可以再次列出，并且所有叶子结点都可以链接在一起

			一棵m阶B+树和m阶的B树的差异：
				有n棵子树的结点中包含有n个关键字
				所有叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点依本身关键字的大小自小而大顺序链接
				所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）的关键字

			如果要随机查找，从根结点出发，即使在分支结点找到了待查找的关键字，也只是用来索引的，并不能提供实际的访问记录，还是需要到达包含此关键字的终端结点
			如果要从最小关键字进行从小到大的顺序查找，就可以从最左侧的叶子几点出发，不经过分支结点，而是沿着指向下一叶子的指针就可以遍历所有的关键字。
			适合带有范围的查找


		#散列表
			存储位置 = f(关键字)
			散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)
			查找时，根据这个确定的对应关系找到给定的值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。
			f成为散列函数，又称为哈希函数
			采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间成为散列表或哈希表。
			散列技术即使一种存储方法，也是一种查找方法。
			散列主要是面向查找的存储结构，散列技术最适合的求解问题是查找与给定值相等的记录。但是散列技术不具备很多常规数据结构的能力。
			两个关键字key1 != key2，但是f(key1) == f(key2)，这种现象称为冲突，并把key1和key2称为这个散列函数的同义词。

			好的散列函数设计原则：
				1、计算简单
				2、散列地址分布均匀

			方法：
				1、直接定址法
					f(key) = a * key + b(a,b为常数)
					优点：简单，均匀，不产生冲突，
					缺点：实现知道关键字分布情况，适合查找表小且连续的情况
				2、数字分析法
					抽取：使用关键字的一部分来计算散列存储位置的方法。
					适合处理关键字位数比较大的情况，若实现知道关键字的分布且关键字的若干为分布均匀，可以考虑使用
				3、平方取中法
					1234的平方为1522756，抽取中间3位 227，用作散列地址。
					适合于不知道关键字分布，且位数不是很大的情况
				4、折叠法
					将关键字从做到右分割成位数相等的几部分（最后一部分位数不够可以短些），然后这几部分叠加求和，并按散列表表长，取后几位做散列地址
					如9876543210，散列表表长位三位，分为4组，987 + 654 + 321 + 0 = 1962，取后3位得到地址962
					有时候这样不够均匀，不妨从一端向另一端来回折叠后对其相加，比如987和321反转，在于654 和 0相加
					789 + 654 + 123 + 0 = 1566，地址位566
					不需要知道关键字分布，适合关键字位数较多的情况
				5、除留余数法
					对于散列表长位m的散列函数公式为
						f(key) = key mod p(p <= m)
					可以对关键字直接取模，也可以在折叠、平方取中后再取模。
					若散列表表长位m，通常p位小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数
				6、随机数法
					f(key) = random(key)
					当关键字长度不等时，采用这个方法。

				不同情况应采用不同的散列函数，参考因素如下：
					计算散列地址所需时间
					关键字长度
					散列表大小
					关键字分布情况
					记录查找的频率

				处理散列冲突的方法：
					1、开放定址法
						一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
						fi(key) = (f(key) + di) mod m（di = 1,2,3,..., m-1）
						把这种解决冲突的开放定址法称为限行探测法
						会出现堆积 ： 本来都不是同义词却需要争夺一个地址的情况

						增加平方运算，不让关键字都聚集在某一块区域。成为二次探测法(等同于可以双向寻找可能的空位置)
						fi(key) = (f(key) + di) mod m（di = 1^2, -1^2, 2^2, -2^2,...,q^2, -q^2, q <= m/2）
						还有一种方法，在冲突时，对于位移量di采用随机函数计算得到，成为随机探测法。（伪随机数）
							伪随机数：设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，用同样的随机种子，得到的数列相同。

					2、再散列函数法
						对于散列表来说，事先准备多个散列函数
							fi(key) = RHi(key)
							RHi为不同的散列函数。能够使得关键字不产生聚集。相应的也增加了计算时间
					3、链地址法
						将所有关键字为同义词的记录存储在一个单链表中，称为同义词字表，散列表中只存储所有同义词子表的头指针。
						提供了绝对不会出现找不到地址的保证，也带来了查找时需要遍历单链表的性能损耗
					4、公共溢出区法
						分为基本表和溢出表
					

				散列表查找的平均长度取决因素
					1、散列函数是否均匀
					2、处理冲突的方法
					3、散列表的装填因子
						装填因子 = 填入表中的记录个数 / 散列表长度
						标志着散列表的装满成都，装填因子越大，产生冲突的可能性就越大。