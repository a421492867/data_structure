#Chapter 7  	图

	#def：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中G表示一个图，V是图G中顶点的集合，E
		 是图G中边的集合


	若顶点Vi到Vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi, Vj)表示。若图中任意两个顶点之间的边都是无向边，则称该图
	为无向图


	若从顶点Vi到Vj的边有方向，则称这条边为有向边，也称为弧，用有序偶对<Vi, Vj>表示，Vi称为弧尾，Vj称为弧头。

	在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有[n * (n - 1)] / 2条边

	在有向图中，若果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n * (n - 1)条边


	图的边或弧相关的数叫做权。带权的图称为网。

	假设有两个图G = (V,{E})和 G' = (V', {E'})，若果V'属于V且E‘属于E，则G’为G的子图

	对于无向图G=(V,{E})，如果边（V，V‘）属于E，则称顶点V和V‘互为邻接点，边（V，V’）依附于顶点V和V‘

	顶点V的度是和V相关联的边的数目，记作TD(V)

	对于无向图，边数就是各顶点度数和的一半

	对于有向图，如果<V,V'>属于E，则称顶点V邻接到V‘，顶点V’邻接自V。以顶点V为头的弧的数目称为V的入度(ID(v))；以V为尾的弧的数目称为V的出度(OD(v))，顶点V的度TD(v) = ID(v) + OD(v)。各顶点出度和 = 个顶点入度和

	路径的长度是路径上的边或弧的数目

	第一个顶点到最后一个顶点相同的路径称为回路或环。序列顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

	在无向图G中，若果从顶点V到顶点V‘有路径，则称V和V’是连通的。如果对于图中任意两个顶点Vi，Vj属于E，Vi和Vj都是连通的，则G是连通图

	无向图中极大连通子图称为连通分量
		1、子图
		2、子图连通
		3、连通子图含有极大顶点数
		4、具有极大顶点数的连通子图包含依附于这些顶点的所有边

	在有向图G中，如果对于每一对Vi、Vj属于V，Vi ！= Vj，从Vi到Vj都存在路径，则称G是强连通图。有向图中的极大强连通子图称为有向图的强连通分量。

	一棵连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但是只有足以构成一棵树的n - 1条边
		如果一个图有n个顶点和小于n - 1条边，则是非连通图；多于n - 1条边，必构成一个环
		有n - 1条边不一定是生成树

	如果一个有向图恰有一个顶点的入度为0，其余顶点入度为1，则是一棵有向树

	一棵有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不想交的有向树的弧


	#图的存储结构
		#邻接矩阵
			图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组存储图中的边或弧的信息。
				#无向图的边数组是一个对称矩阵

			若为网图，则将权值存入边信息，若i = j 则为0， 否则为 ∞


		#邻接表
			对于边数相对顶点较少的图，邻接矩阵则存在对存储空间的极大浪费。

			-> 数组和链表结合的存储方法
				1、图中顶点用一个一维数组存储
				2、图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点个数布丁，所以用单链表存储

				网图可在边表结点定义中增加weight数据域，存放权值
		#十字链表
			邻接表和逆邻接表结合起来
			定义顶点表结点结构：
				data firstin firstout
					firstin指入边表头指针，指向该顶点的入边表中的第一个结点
					firstout表示出边表头指针，指向该顶点的出边表中的第一个结点
			定义边表结点结构：
				tailvex headvex headlink taillink
					tailvex指弧起点在顶点表的下标，headvex指弧终点在顶点表中的下标，
					headlink指入边表指针域，指向终点相同的下一条边
					taillink指边表指针域，指向起点相同的下一条边
					如果是网，可以在增加一个weight域来存储权值

			
		#邻接多重表
			定义多重链表：
				ivex ilink jvex jlink
					ivex和jvex是与某条边依附的两个顶点在顶点表中的下标
					ilink指向依附顶点ivex的下一条边
					jlink指向依附顶点jvex的下一条边
				ilink指向的结点jvex和本身ivex值相同

		#边集数组
			边集数组是由两个一维数组构成，一个存储顶点信息，另一个存储边的信息，这个边数组每个数据元素由一条边的起点下标、终点下标和权组成

		#图的遍历
			#深度优先遍历 DFS
				从图中某个顶点V出发，访问此顶点，然后从V的未被访问的临界点出发深度优先遍历图，直至涂红所有和V有路径想通的顶点都被访问到。

				对于非连通图，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到为止

				类似树的前序遍历

			#广度优先遍历 BFS
				类似于树的层序遍历

		#最小生成树
			#Prim算法
				1).输入：一个加权连通图，其中顶点集合为V，边集合为E；

				2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；

				3).重复下列操作，直到Vnew = V：

					a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；

					b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；

				4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。

			#Kruskal
				假设N = (V,{E})是连通图，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T = (V,{})，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同连通分量上，则将此边加到T中，否则舍去此边而选择下一条代价最小的边，依次类推，直至T中所有结点都在同一连通分量上为止。

			比较：
				Kruskal针对边展开，边数少效率高，所以稀疏图有很大优势，Prim则对于稠密图。

		#最短路径
			#Dijkstra
				一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径

			#Floyd
				D[v][w] = min(D[v][w], D[v][k] + D[k][w])
				动态规划算法
				D数组和P数组

		#拓扑排序
			对一个有向图构造拓扑序列的过程

			基本思路：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，重复此步骤，直到输出的全部顶点或者AOV网中不存在入度为0的顶点为止。